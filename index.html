<!DOCTYPE html>
<html lang="zh-CN">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rust 常见疑问汇总</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="highlight.css">
<header>
  <h1>Rust 常见疑问汇总</h1>
</header>
<main>
  <article>
    <h2 id="async-fn-in-trait"><a href="#async-fn-in-trait">如何在特质里添加异步函数？</a></h2><p>目前 Rust 不支持在<a title="trait">特质</a>里直接添加<a title="async function">异步函数</a>，但可以使用 <a href="https://crates.io/crates/async-trait">async-trait</a> 这个库来实现。这个库会将异步函数改写为返回 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 的普通函数以绕过目前语言层面的限制，但也因此有堆分配以及<a title="dynamic dispatch">动态分发</a>这两个额外的代价，所以不会被直接添加到 Rust 语言中。</p><p>在特质里不支持使用异步函数是由于异步函数本质上是一个返回 <code>impl Future&lt;Output = T&gt;</code> 的函数，而目前 Rust 的类型系统还无法表达在特质的方法的返回类型上使用 <code>impl Trait</code>。有两个已经通过的 RFC 旨在解决这一问题：<a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html">RFC 1598</a> 泛型关联类型和 <a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">RFC 2071</a> <code>impl Trait</code> <a title="existential type">存在类型</a>，但它们的编译器支持还在实现中。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/async-fn-in-trait.md">编辑</a>
  </article>
  <article>
    <h2 id="await-multiple-futures"><a href="#await-multiple-futures">如何同时等待多个 <code>Future</code>？</a></h2><p>如果想要等待多个 <code>Future</code> 都完成后返回，对于固定数量的 <code>Future</code> 可以使用 <a href="https://crates.io/crates/futures"><code>futures</code></a> 所提供的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join.html"><code>join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join3.html"><code>join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join4.html"><code>join4</code></a> 等函数，或者 <a href="https://crates.io/crates/tokio"><code>tokio</code></a> 所提供的 <a href="https://docs.rs/tokio/1/tokio/macro.join.html"><code>join!</code></a> 宏，将多个 <code>Future</code> 合并为一个进行等待。对于不定数量的 <code>Future</code>，比如有一个 <code>Vec</code>，则可以使用 <code>futures</code> 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join_all.html"><code>join_all</code></a> 函数。</p><p>若要在数个 <code>Future</code> 中第一个错误发生时就返回，则可以使用它们对应的 <a href="https://docs.rs/futures/0.3/futures/future/fn.try_join.html"><code>try_join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join3.html"><code>try_join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join4.html"><code>try_join4</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join_all.html"><code>try_join_all</code></a> 等函数以及 <a href="https://docs.rs/tokio/1/tokio/macro.try_join.html"><code>try_join!</code></a> 宏。</p><p>如果想要在多个 <code>Future</code> 中的第一个完成后就返回，可以使用 <code>futures</code> 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.select.html"><code>select</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.select_all.html"><code>select_all</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/future/fn.select_ok.html"><code>select_ok</code></a> 函数或 <code>tokio</code> 的 <a href="https://docs.rs/tokio/1/tokio/macro.select.html"><code>select!</code></a> 宏。</p><p>需要注意的是，上面这些函数和宏在每次被轮询的时候，都会轮询里面每一个未完成的 <code>Future</code>，因此当其所带的 <code>Future</code> 很多时可能会有性能问题。</p><p>使用 <code>futures</code> 提供的 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesOrdered.html"><code>FuturesOrdered</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesUnordered.html"><code>FuturesUnordered</code></a> 这两个结构可以解决这一问题。它们是为管理大量的 <code>Future</code> 而设计的，只会去轮询收到了唤醒通知的 <code>Future</code>。它们将这些 <code>Future</code> 聚合成一个 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 逐个返回里面 <code>Future</code> 的结果，其中前者会按照输入的 <code>Future</code> 的顺序返回，而后者则是以任意顺序（可以近似看作按照完成顺序）返回。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/await-multiple-futures.md">编辑</a>
  </article>
  <article>
    <h2 id="binary-size"><a href="#binary-size">为什么 Rust 生成的程序体积比较大？如何最小化程序体积？</a></h2><p>有多个因素使得 Rust 在默认情况下有着相对较大的程序体积，包括了<a title="monomorphization">单态化</a>、调试符号、标准库等。一般来说，Rust 偏向于为性能优化而非更小的体积。</p><p>通常使用发布模式编译（<code>--release</code>），以及（在 Linux 和 macOS 下）使用 <code>strip</code> 删除符号信息可以在一定程度上缩小程序体积。更多方法可以参考 <a href="https://github.com/johnthagen/min-sized-rust">Minimizing Rust Binary Size</a>，对这一问题有较完整的介绍。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/binary-size.md">编辑</a>
  </article>
  <article>
    <h2 id="common-ide"><a href="#common-ide">写 Rust 有哪些常用的开发环境？</a></h2><p>目前来看，最流行的 Rust 开发环境是 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 配合 <a href="https://rust-analyzer.github.io/">rust-analyzer</a>，其次是在 <a href="https://www.jetbrains.com/clion/">CLion</a> 或其他 <a href="https://www.jetbrains.com/products.html#type=ide">IntelliJ</a> 平台的 IDE 上安装 <a href="https://intellij-rust.github.io/">Intellij Rust</a> 插件。使用 <a href="https://www.vim.org/">Vim</a> 或 <a href="https://www.gnu.org/software/emacs/">Emacs</a> 进行开发的也不在少数，此外也有人使用其他编辑器。</p><p>Rust 群关于这一问题有定期调查：</p><ul><li>2020年：<a href="https://t.me/c/1264662201/96391">5月</a>、<a href="https://t.me/c/1264662201/116314">8月</a>、<a href="https://t.me/c/1264662201/130996">11月</a></li><li>2021年：<a href="https://t.me/c/1264662201/147028">2月</a></li></ul>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/common-ide.md">编辑</a>
  </article>
  <article>
    <h2 id="error-handling"><a href="#error-handling">错误处理推荐使用什么库？</a></h2><p>目前一般认为对于应用程序推荐使用 <a href="https://crates.io/crates/anyhow">anyhow</a>，而对于库推荐使用 <a href="https://crates.io/crates/thiserror">thiserror</a>。</p><p>anyhow 提供了一个基于<a title="trait object">特质对象</a>的错误类型，可以很容易地将不同来源的错误统一到单一来源，并可以方便地为错误添加上下文，以及就地创建新的错误。</p><p>thiserror 则提供了一个 derive 宏，方便为自定义的错误类型实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> 特质</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/error-handling.md">编辑</a>
  </article>
  <article>
    <h2 id="fn-pointer-fn-trait"><a href="#fn-pointer-fn-trait"><code>fn()</code> 类型与 <code>Fn()</code> 等特质的关系和区别是什么？</a></h2><p>在 Rust 中，每一个函数，无论是由 <code>fn</code> 关键字定义的一般函数，还是由闭包表达式定义的闭包，都有一个各自独立的匿名类型。为了能间接地使用函数，Rust 准备了两种方式，即 <code>fn()</code> 类型与 <code>Fn()</code>、<code>FnMut()</code> 和 <code>FnOnce()</code> 等<a title="trait">特质</a>。</p><p>要表达不同的类型，最常见的方法即是使用特质（作为类型约束，即 <code>T: Fn()</code> 和 <code>impl Fn()</code>，或者使用<a title="trait object">特质对象</a>，即 <code>dyn Fn()</code>），<code>Fn()</code> 一族就是用于表达函数类型的特质。</p><p><code>fn()</code> 不是一个特质，而是一个具体的类型，表示一个函数指针。功能上它与特质对象类似，可以近似地看作 <code>&amp;&#x27;static dyn Fn()</code>。但 <code>fn()</code> 与 <code>Fn()</code> 不同，它不包含对上下文的引用，因而只有一般函数或没有捕获任何上下文的闭包能够被转换成 <code>fn()</code>。因此它也与 <code>&amp;dyn Fn()</code> 不同，不需要使用<a title="fat pointer">胖指针</a>。它的大小与普通的指针一致。</p><p>因为 <code>fn()</code> 是一个函数指针，通过它调用函数与通过特质对象一样是间接调用，而使用 <code>Fn()</code> 等特质约束的泛型则是通过<a title="monomorphization">单态化</a>来直接调用的。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/fn-pointer-fn-trait.md">编辑</a>
  </article>
  <article>
    <h2 id="format-macro"><a href="#format-macro">格式化字符串的方法，如 <code>println</code>、<code>info</code> 等一般通过宏来实现，这是为什么？</a></h2><p>因为 Rust 里函数不支持变长参数，因而如果要做编译期类型检查，就必须通过宏来实现。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/format-macro.md">编辑</a>
  </article>
  <article>
    <h2 id="future-poll-perf"><a href="#future-poll-perf">Rust 的 <code>Future</code> 是基于轮询的，这种方式不会有性能问题吗？</a></h2><p><code>Future</code> 的轮询是带通知机制的轮询，与传统意义上的轮询不完全一样。</p><p>当<a title="executor">执行器</a>调用 <code>Future</code> 的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll"><code>poll</code></a> 方法时会传入一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>，而 <code>Future</code> 可以将这个 <code>Waker</code> 保存起来，当自己的状态有所变化时，通过其通知执行器可以再次对自己进行轮询。通过这个机制，执行器可以避免反复轮询一个未准备好的 <code>Future</code>，避免了传统轮询带来的性能问题。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/future-poll-perf.md">编辑</a>
  </article>
  <article>
    <h2 id="futures-rel"><a href="#futures-rel">标准库的 <code>Future</code>、futures crate、tokio 和 async-std 等之间的关系是什么？</a></h2><p>标准库的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> <a title="trait">特质</a>以及相关的 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a>、<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a>、<a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 等是核心。由于编译器编译<a title="async function">异步函数</a>需要依赖它们的定义，因而它们必须被包含在标准库里。</p><p><a href="https://crates.io/crates/futures">futures</a> 是 <code>Future</code> 的扩展，提供了许多虽不必进入标准库但依然重要的基础性的东西，比如 <a href="https://docs.rs/futures/0.3/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>、<a href="https://docs.rs/futures/0.3/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a> 等扩展特质和基础的<a href="https://docs.rs/futures/0.3/futures/channel/index.html">通道</a>、<a href="https://docs.rs/futures/0.3/futures/executor/index.html">执行器</a>实现等。</p><p><a href="https://crates.io/crates/tokio">tokio</a> 和 <a href="https://crates.io/crates/async-std">async-std</a> 是同一个层次的，主要提供异步运行时的实现，都依赖 futures 提供的元语，但因为处理的层次不同，所以可以看到一些自定义的与 futures 差不多的模块。</p><p>此外，虽然目前 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 是由 futures 提供的，但未来如果编译器要实现<a href="https://rust-lang.github.io/rfcs/2394-async_await.html#generators-and-streams" title="async generator">异步生成器</a>，这个特质也很可能会进入标准库，因而对其的扩展也依然放进了独立的 <code>StreamExt</code> 里。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/futures-rel.md">编辑</a>
  </article>
  <article>
    <h2 id="generic-primitive-num"><a href="#generic-primitive-num">如何约束一个泛型参数为基本数值类型？</a></h2><p>可以使用由 <a href="https://crates.io/crates/num-traits">num-traits</a> 所提供的 <a href="https://docs.rs/num-traits/0.2/num_traits/int/trait.PrimInt.html"><code>PrimInt</code></a> 和 <a href="https://docs.rs/num-traits/0.2/num_traits/float/trait.Float.html"><code>Float</code></a> 两个<a title="trait">特质</a>来约束泛型参数为基本整数类型和浮点数类型。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/generic-primitive-num.md">编辑</a>
  </article>
  <article>
    <h2 id="heap-new"><a href="#heap-new">如何直接在堆上分配新的对象或数组？</a></h2><p>目前 Rust 语言本身没有提供稳定且不使用 <code>unsafe</code> 的方式能保证将一个对象或数组直接分配到堆上。</p><p><code>Box::new([0; 4096])</code> 等方式在语义上是在栈上创建数组，然后再移动到堆上。<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> 等容器类型的内容会直接分配在堆上，因而也可以通过 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a> 从一个 <code>Vec</code> 得到堆上切片 <code>Box&lt;[T]&gt;</code>，再通过 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-TryFrom%3CBox%3C%5BT%5D%3E%3E"><code>TryFrom</code></a> 获得堆上数组 <code>Box&lt;[T; N]&gt;</code>。不过添加每个元素从语义上依然是在栈上分配再移入容器的。</p><p>有一些第三方的库，如 <a href="https://crates.io/crates/copyless"><code>copyless</code></a>、<a href="https://crates.io/crates/boxext"><code>boxext</code></a> 和 <a href="https://crates.io/crates/default-boxed"><code>default-boxed</code></a> 等，通过依赖编译器优化或包装 <code>unsafe</code> 的功能来提供安全的接口进行直接分配。</p><p>使用 <code>unsafe</code> 的话可以通过调用 <a href="https://doc.rust-lang.org/std/alloc/fn.alloc.html"><code>alloc</code></a> 函数直接分配堆内存并取得指针，但需要手动初始化和管理分配的内存。<code>Box</code> 及其他智能指针类型未来很可能会提供 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit"><code>new_uninit</code></a>、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit_slice"><code>new_uninit_slice</code></a> 等方法在堆上直接创建 <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>，但你仍将需要使用 <code>unsafe</code> 的方式来初始化其内容。</p><p>未稳定的 <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/box-syntax.html"><code>box</code> 语法</a>在一些情况下可以直接分配到堆上并创建一个 <code>Box</code>，但当有嵌套表达式，如 <code>box Wrapper([0; 4096])</code>，时则依然会有先分配在栈上再移入堆的问题。而且 <code>box</code> 语法目前也没有稳定化的计划。</p><p>此外，有一些提案，如 <a href="https://github.com/rust-lang/rfcs/pull/2884">RFC 2884</a>，试图提供新的接口来解决这一问题，但目前还没有足够的共识。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/heap-new.md">编辑</a>
  </article>
  <article>
    <h2 id="trait-obj-upcast"><a href="#trait-obj-upcast">如果有一个 <code>trait Foo: Base</code>，如何将一个 <code>&amp;dyn Foo</code> 转换到 <code>&amp;dyn Base</code>？</a></h2><p>Rust 目前不直接提供这种转换，如果需要转换可以使用一个中间<a title="trait">特质</a>来实现，如</p><pre class="code"><span class="s-source s-rust"><span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Base</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...
</span></span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">AsBase</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span></span><span class="s-punctuation s-terminator s-rust">;</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-impl s-rust"><span class="s-storage s-type s-impl s-rust">impl</span></span><span class="s-meta s-impl s-rust"><span class="s-meta s-generic s-rust"><span class="s-punctuation s-definition s-generic s-begin s-rust">&lt;</span>T<span class="s-punctuation s-separator s-rust">:</span> Base<span class="s-punctuation s-definition s-generic s-end s-rust">&gt;</span></span></span><span class="s-meta s-impl s-rust"> AsBase <span class="s-keyword s-other s-rust">for</span></span><span class="s-meta s-impl s-rust"> <span class="s-entity s-name s-impl s-rust">T</span> </span><span class="s-meta s-impl s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span> </span><span class="s-meta s-function s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span> <span class="s-variable s-language s-rust">self</span> </span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Foo</span>: AsBase <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...
</span></span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span></pre><p>不支持的主要原因是在<a title="trait object">特质对象</a>的<a title="vtable">虚表</a>中没有相应的数据指向另一个特质的虚表，而不提供相应数据的原因可能是由于这很容易产生过多无用的虚表，进而导致二进制体积的膨胀。</p><p>更多关于这一话题的讨论可以参考 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 以及 <a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting">Traits, dynamic dispatch and upcasting</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/trait-obj-upcast.md">编辑</a>
  </article>
  <article>
    <h2 id="vec-new-ptr"><a href="#vec-new-ptr">新创建的空 <code>Vec&lt;T&gt;</code> 的指针为何指向<code>1</code>、<code>2</code>、<code>4</code>、<code>8</code>等地址？</a></h2><p>当 <code>Vec</code> 的容量为0时，没有合法的操作会向其指针指向的位置进行读取和写入，进行任何读写之前都必然会有一次内存分配，因此这个初始的指针并不需要是一个有效的指针。这也使得创建 <code>Vec</code> 本身没有进行实际内存分配的必要，既省去了内存分配的开销，也让创建容器的操作可以在常量上下文中使用。</p><p>而因为 <code>Vec</code> 需要能被作为<a title="slice">切片</a>使用，由于切片对数据指针的<a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety">要求</a>，它的指针的地址需要是非空并且正确对齐的，因而简单起见便选择了类型的对齐的大小作为这个无效指针指向的地址。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/vec-new-ptr.md">编辑</a>
  </article>
  <div class="add-container">
    <a class="add" href="https://github.com/rust-zh/faq/tree/master/content">+ 贡献新条目</a>
  </div>
</main>
<footer>
  <a class="telegram" href="https://t.me/rust_zh">Rust 众</a>
  <a rel="license" class="cc0" href="https://creativecommons.org/publicdomain/zero/1.0/deed.zh">CC0</a>
</footer>
</html>
