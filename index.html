<!DOCTYPE html>
<html lang="zh-CN">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rust 常见疑问汇总</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="highlight.css">
<header>
  <h1>Rust 常见疑问汇总</h1>
</header>
<main>
<article>
    <h2 id="async-fn-in-trait"><a href="#async-fn-in-trait">如何在特质里添加异步函数？</a></h2><p>目前 Rust 不支持在<a title="trait">特质</a>里直接添加<a title="async function">异步函数</a>，但可以使用 <a href="https://crates.io/crates/async-trait">async-trait</a> 这个库来实现。这个库会将异步函数改写为返回 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 的普通函数以绕过目前语言层面的限制，但也因此有堆分配以及<a title="dynamic dispatch">动态分发</a>这两个额外的代价，所以不会被直接添加到 Rust 语言中。</p><p>在特质里不支持使用异步函数是由于异步函数本质上是一个返回 <code>impl Future&lt;Output = T&gt;</code> 的函数，而目前 Rust 的类型系统还无法表达在特质的方法的返回类型上使用 <code>impl Trait</code>。有两个已经通过的 RFC 旨在解决这一问题：<a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html">RFC 1598</a> 泛型关联类型和 <a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">RFC 2071</a> <code>impl Trait</code> <a title="existential type">存在类型</a>，但它们的编译器支持还在实现中，实现进度可以参考 <a href="https://rust-lang.github.io/impl-trait-initiative/">impl Trait 计划</a>的页面。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/async-fn-in-trait.md">编辑</a>
  </article>
<article>
    <h2 id="await-multiple-futures"><a href="#await-multiple-futures">如何同时等待多个 <code>Future</code>？</a></h2><p>如果想要等待多个 <code>Future</code> 都完成后返回，对于固定数量的 <code>Future</code> 可以使用 <a href="https://crates.io/crates/futures">futures</a> 所提供的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join.html"><code>join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join3.html"><code>join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.join4.html"><code>join4</code></a> 等函数，或者 <a href="https://crates.io/crates/tokio">tokio</a> 所提供的 <a href="https://docs.rs/tokio/1/tokio/macro.join.html"><code>join!</code></a> 宏，将多个 <code>Future</code> 合并为一个进行等待。对于不定数量的 <code>Future</code>，比如有一个 <code>Vec</code>，则可以使用 futures 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.join_all.html"><code>join_all</code></a> 函数。</p><p>若要在数个 <code>Future</code> 中第一个错误发生时就返回，则可以使用它们对应的 <a href="https://docs.rs/futures/0.3/futures/future/fn.try_join.html"><code>try_join</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join3.html"><code>try_join3</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join4.html"><code>try_join4</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.try_join_all.html"><code>try_join_all</code></a> 等函数以及 <a href="https://docs.rs/tokio/1/tokio/macro.try_join.html"><code>try_join!</code></a> 宏。</p><p>如果想要在多个 <code>Future</code> 中的第一个完成后就返回，可以使用 futures 的 <a href="https://docs.rs/futures/0.3/futures/future/fn.select.html"><code>select</code></a>、<a href="https://docs.rs/futures/0.3/futures/future/fn.select_all.html"><code>select_all</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/future/fn.select_ok.html"><code>select_ok</code></a> 函数或 tokio 的 <a href="https://docs.rs/tokio/1/tokio/macro.select.html"><code>select!</code></a> 宏。</p><p>此外，futures 还提供了 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesOrdered.html"><code>FuturesOrdered</code></a> 和 <a href="https://docs.rs/futures/0.3/futures/stream/struct.FuturesUnordered.html"><code>FuturesUnordered</code></a> 两个结构，它们将这些 <code>Future</code> 聚合成一个 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 逐个返回里面 <code>Future</code> 的结果。其中前者会按照输入的 <code>Future</code> 的顺序返回，而后者则是以任意顺序（可以近似看作按照完成顺序）返回。这两个结构额外提供了 <code>push</code> 方法来动态插入新的 <code>Future</code>，而且它们只会 <code>poll</code> 被唤醒的 <code>Future</code>，在 <code>Future</code> 数量较多时可能更高效。前面提到的 <code>join_all</code> 也会在一些情况下会自动使用 <code>FuturesOrdered</code> 来优化。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/await-multiple-futures.md">编辑</a>
  </article>
<article>
    <h2 id="binary-size"><a href="#binary-size">为什么 Rust 生成的程序体积比较大？如何最小化程序体积？</a></h2><p>有多个因素使得 Rust 在默认情况下有着相对较大的程序体积，包括了<a title="monomorphization">单态化</a>、调试符号、标准库等。一般来说，Rust 偏向于为性能优化而非更小的体积。</p><p>通常使用发布模式编译（<code>--release</code>），以及（在 Linux 和 macOS 下）使用 <code>strip</code> 删除符号信息可以在一定程度上缩小程序体积。更多方法可以参考 <a href="https://github.com/johnthagen/min-sized-rust">Minimizing Rust Binary Size</a>，对这一问题有较完整的介绍。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/binary-size.md">编辑</a>
  </article>
<article>
    <h2 id="common-ide"><a href="#common-ide">写 Rust 有哪些常用的开发环境？</a></h2><p>目前来看，最流行的 Rust 开发环境是 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 配合 <a href="https://rust-analyzer.github.io/">rust-analyzer</a>，其次是在 <a href="https://www.jetbrains.com/clion/">CLion</a> 或其他 <a href="https://www.jetbrains.com/products.html#type=ide">IntelliJ</a> 平台的 IDE 上安装 <a href="https://intellij-rust.github.io/">Intellij Rust</a> 插件。使用 <a href="https://www.vim.org/">Vim</a> 或 <a href="https://www.gnu.org/software/emacs/">Emacs</a> 进行开发的也不在少数，此外也有人使用其他编辑器。</p><p>Rust 群关于这一问题有定期调查：</p><ul><li>2020年：<a href="https://t.me/c/1264662201/96391">5月</a>、<a href="https://t.me/c/1264662201/116314">8月</a>、<a href="https://t.me/c/1264662201/130996">11月</a></li><li>2021年：<a href="https://t.me/c/1264662201/147028">2月</a>、<a href="https://t.me/c/1264662201/172603">6月</a>、<a href="https://t.me/c/1264662201/187446">9月</a>、<a href="https://t.me/c/1264662201/208793">12月</a></li><li>2022年：<a href="https://t.me/c/1264662201/229789">3月</a>、<a href="https://t.me/c/1264662201/254624">6月</a>、<a href="https://t.me/c/1264662201/289597">9月</a>、<a href="https://t.me/c/1264662201/319656">12月</a></li><li>2023年：<a href="https://t.me/c/1264662201/354506">3月</a></li></ul>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/common-ide.md">编辑</a>
  </article>
<article>
    <h2 id="debug-build-slow"><a href="#debug-build-slow">为什么使用调试模式构建的 Rust 程序运行速度很慢？</a></h2><p>当不指定任何标志时使用 <code>cargo build</code> 或 <code>cargo run</code> 来构建或运行 Rust 程序，会默认使用调试模式来进行构建，这时编译出的 Rust 程序运行速度很慢，有时甚至不及等效的 Python 代码。加上 <code>--release</code> 标志时会使用发布模式来构建，这样编译出的程序运行速度会快得多。造成这种现象的原因主要有两点：</p><p>一是调试模式构建主要是针对编译速度而非运行速度进行优化，因为在开发过程中我们常需要反复编辑、编译和调试，加速编译可以加快总体开发速度。但当为编译速度优化时，一方面，很多为加快运行速度但会拖慢编译的编译器优化会被禁用。由于 Rust 的库和程序通常有很多抽象设施，它们虽然给编写程序带来便利，但在调试模式下却可能无法被完全优化掉，进而拖慢运行速度。另一方面，调试模式下默认会启用一些额外的机制加快编译速度，如<a title="incremental compilation">增量编译</a>和<a title="parallel codegen">并发代码生成</a>，这些优化虽然加快了编译速度，但同时也牺牲了编译结果的质量，降低了运行速度。</p><p>二是调试模式下会启用一些额外的检测，而这些检测会增加运行时间。在调试模式下，编译器默认会为内置整数类型的算数运算插入溢出检查，在溢出发生时 panic 以帮助发现潜在的逻辑问题，而在发布模式下则没有这一检查。此外还有提供如 <a href="https://doc.rust-lang.org/std/macro.debug_assert.html"><code>debug_assert!</code></a> 宏和 <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions"><code>debug_assertions</code></a> 条件编译选项等设施让库和应用可以根据需要在调试模式下额外执行一些较为昂贵的运行时检查。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/debug-build-slow.md">编辑</a>
  </article>
<article>
    <h2 id="error-handling"><a href="#error-handling">错误处理推荐使用什么库？</a></h2><p>目前一般认为对于应用程序推荐使用 <a href="https://crates.io/crates/anyhow">anyhow</a>，而对于库推荐使用 <a href="https://crates.io/crates/thiserror">thiserror</a>。</p><p>anyhow 提供了一个基于<a title="trait object">特质对象</a>的错误类型，可以很容易地将不同来源的错误统一到单一类型，并可以方便地为错误添加上下文，以及就地创建新的错误。</p><p>thiserror 则提供了一个 derive 宏，方便为自定义的错误类型实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> 特质</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/error-handling.md">编辑</a>
  </article>
<article>
    <h2 id="fn-pointer-fn-trait"><a href="#fn-pointer-fn-trait"><code>fn()</code> 类型与 <code>Fn()</code> 等特质的关系和区别是什么？</a></h2><p>在 Rust 中，每一个函数，无论是由 <code>fn</code> 关键字定义的一般函数，还是由闭包表达式定义的闭包，都有一个各自独立的匿名类型。为了能间接地使用函数，Rust 准备了两种方式，即 <a href="https://doc.rust-lang.org/std/primitive.fn.html"><code>fn()</code></a> 类型与 <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn()</code></a>、<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut()</code></a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce()</code></a> 等<a title="trait">特质</a>。</p><p>要表达不同的类型，最常见的方法即是使用特质（作为类型约束，即 <code>T: Fn()</code> 和 <code>impl Fn()</code>，或者使用<a title="trait object">特质对象</a>，即 <code>dyn Fn()</code>），<code>Fn()</code> 一族就是用于表达函数类型的特质。</p><p><code>fn()</code> 不是一个特质，而是一个具体的类型，表示一个函数指针。功能上它与特质对象类似，可以近似地看作 <code>&amp;&#x27;static dyn Fn()</code>。但 <code>fn()</code> 与 <code>Fn()</code> 不同，它不包含对上下文的引用，因而只有一般函数或没有捕获任何上下文的闭包能够被转换成 <code>fn()</code>。因此它也与 <code>&amp;dyn Fn()</code> 不同，不需要使用<a title="fat pointer">胖指针</a>。它的大小与普通的指针一致。</p><p>因为 <code>fn()</code> 是一个函数指针，通过它调用函数与通过特质对象一样是间接调用，而使用 <code>Fn()</code> 等特质约束的泛型则是通过<a title="monomorphization">单态化</a>来直接调用的。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/fn-pointer-fn-trait.md">编辑</a>
  </article>
<article>
    <h2 id="format-macro"><a href="#format-macro">格式化字符串的方法，如 <code>println</code>、<code>info</code> 等一般通过宏来实现，这是为什么？</a></h2><p>因为 Rust 里函数不支持变长参数，因而如果要做编译期类型检查，就必须通过宏来实现。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/format-macro.md">编辑</a>
  </article>
<article>
    <h2 id="future-poll-perf"><a href="#future-poll-perf">Rust 的 <code>Future</code> 是基于轮询的，这种方式不会有性能问题吗？</a></h2><p><code>Future</code> 的轮询是带通知机制的轮询，与传统意义上的轮询不完全一样。</p><p>当<a title="executor">执行器</a>调用 <code>Future</code> 的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll"><code>poll</code></a> 方法时会传入一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>，而 <code>Future</code> 可以将这个 <code>Waker</code> 保存起来，当自己的状态有所变化时，通过其通知执行器可以再次对自己进行轮询。通过这个机制，执行器可以避免反复轮询一个未准备好的 <code>Future</code>，避免了传统轮询带来的性能问题。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/future-poll-perf.md">编辑</a>
  </article>
<article>
    <h2 id="futures-rel"><a href="#futures-rel">标准库的 <code>Future</code>、futures crate、tokio 和 async-std 等之间的关系是什么？</a></h2><p>标准库的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> <a title="trait">特质</a>以及相关的 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a>、<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a>、<a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 等是核心。由于编译器编译<a title="async function">异步函数</a>需要依赖它们的定义，因而它们必须被包含在标准库里。</p><p><a href="https://crates.io/crates/futures">futures</a> 是 <code>Future</code> 的扩展，提供了许多虽不必进入标准库但依然重要的基础性的东西，比如 <a href="https://docs.rs/futures/0.3/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>、<a href="https://docs.rs/futures/0.3/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a> 等扩展特质和基础的<a href="https://docs.rs/futures/0.3/futures/channel/index.html">通道</a>、<a href="https://docs.rs/futures/0.3/futures/executor/index.html">执行器</a>实现等。</p><p><a href="https://crates.io/crates/tokio">tokio</a> 和 <a href="https://crates.io/crates/async-std">async-std</a> 是同一个层次的，主要提供异步运行时的实现，都依赖 futures 提供的元语，但因为处理的层次不同，所以可以看到一些自定义的与 futures 差不多的模块。</p><p>此外，虽然目前 <a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>Stream</code></a> 是由 futures 提供的，但未来如果编译器要实现<a href="https://rust-lang.github.io/rfcs/2394-async_await.html#generators-and-streams" title="async generator">异步生成器</a>，这个特质也很可能会进入标准库，因而对其的扩展也依然放进了独立的 <code>StreamExt</code> 里。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/futures-rel.md">编辑</a>
  </article>
<article>
    <h2 id="generic-primitive-num"><a href="#generic-primitive-num">如何约束一个泛型参数为基本数值类型？</a></h2><p>可以使用由 <a href="https://crates.io/crates/num-traits">num-traits</a> 所提供的 <a href="https://docs.rs/num-traits/0.2/num_traits/int/trait.PrimInt.html"><code>PrimInt</code></a> 和 <a href="https://docs.rs/num-traits/0.2/num_traits/float/trait.Float.html"><code>Float</code></a> 两个<a title="trait">特质</a>来约束泛型参数为基本整数类型和浮点数类型。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/generic-primitive-num.md">编辑</a>
  </article>
<article>
    <h2 id="heap-new"><a href="#heap-new">如何直接在堆上分配新的对象或数组？</a></h2><p>目前 Rust 语言本身没有提供稳定且不使用 <code>unsafe</code> 的方式能保证将一个对象或数组直接分配到堆上。</p><p><code>Box::new([0; 4096])</code> 等方式在语义上是在栈上创建数组，然后再移动到堆上。<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> 等容器类型的内容会直接分配在堆上，因而也可以通过 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a> 从一个 <code>Vec</code> 得到堆上切片 <code>Box&lt;[T]&gt;</code>，再通过 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-TryFrom%3CBox%3C%5BT%5D%3E%3E"><code>TryFrom</code></a> 获得堆上数组 <code>Box&lt;[T; N]&gt;</code>。不过添加每个元素从语义上依然是在栈上分配再移入容器的。</p><p>有一些第三方的库，如 <a href="https://crates.io/crates/copyless">copyless</a>、<a href="https://crates.io/crates/boxext">boxext</a> 和 <a href="https://crates.io/crates/default-boxed">default-boxed</a> 等，通过依赖编译器优化或包装 <code>unsafe</code> 的功能来提供安全的接口进行直接分配。</p><p>使用 <code>unsafe</code> 的话可以通过调用 <a href="https://doc.rust-lang.org/std/alloc/fn.alloc.html"><code>alloc</code></a> 函数直接分配堆内存并取得指针，但需要手动初始化和管理分配的内存。<code>Box</code> 及其他智能指针类型未来很可能会提供 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit"><code>new_uninit</code></a>、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit_slice"><code>new_uninit_slice</code></a> 等方法在堆上直接创建 <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>，但你仍将需要使用 <code>unsafe</code> 的方式来初始化其内容。</p><p>未稳定的 <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/box-syntax.html"><code>box</code> 语法</a>在一些情况下可以直接分配到堆上并创建一个 <code>Box</code>，但当有嵌套表达式，如 <code>box Wrapper([0; 4096])</code>，时则依然会有先分配在栈上再移入堆的问题。而且 <code>box</code> 语法目前也没有稳定化的计划。</p><p>此外，有一些提案，如 <a href="https://github.com/rust-lang/rfcs/pull/2884">RFC 2884</a>，试图提供新的接口来解决这一问题，但目前还没有足够的共识。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/heap-new.md">编辑</a>
  </article>
<article>
    <h2 id="static-lifetime-bound-var"><a href="#static-lifetime-bound-var"><code>&amp;&#x27;static T</code>、<code>T: &#x27;static</code>、<code>static</code> 关键字分别表示什么？它们之间有什么联系？</a></h2><h3><code>&amp;&#x27;static T</code></h3><p><code>&amp;&#x27;static T</code> 表示的是一个指向类型为 <code>T</code> 的值的引用，它的<a title="lifetime">生命周期</a>为 <code>&#x27;static</code>。这里的生命周期 <code>&#x27;static</code> 在语义上表示这个引用所指向的值在程序的整个运行期间都不会被释放（但可以使用 <code>unsafe</code> 构造违反这一语义的情况）。</p><p>这样的引用最常来自于<a title="literal">字面量</a>和对字面量的引用（如字符串字面量 <code>&quot;hello world&quot;</code> 的类型为 <code>&amp;&#x27;static str</code>，<code>&amp;[1i32, 2, 3]</code> 的类型为 <code>&amp;&#x27;static [i32; 3]</code>），但它也可以来自于对常量或静态变量的引用，以及通过如 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.leak"><code>Vec::leak</code></a> 等方法放弃<a title="ownership">所有权</a>来获得。</p><p>由于 <code>&#x27;static</code> 生命周期长于任何其他生命周期，一个 <code>&amp;&#x27;static T</code> 类型的引用可以安全地<a title="coerce">强制转换</a>为一个标注为任何生命周期的引用 <code>&amp;&#x27;a T</code>。</p><h3><code>T: &#x27;static</code></h3><p><code>T: &#x27;static</code> 表示的是一个类型约束，它表明类型 <code>T</code> 可以在程序的整个运行期间有效，也即 <code>T</code> 中不包含引用，或包含的所有引用的生命周期都为 <code>&#x27;static</code>，举例来说：</p><ul><li><code>struct Alpha(String, Vec&lt;usize&gt;);</code> 有 <code>Alpha: &#x27;static</code>，因为类型中不包含引用；</li><li><code>struct Beta(&amp;&#x27;static str);</code> 也有 <code>Beta: &#x27;static</code>，因为类型中的所有引用都是 <code>&#x27;static</code> 的；</li><li><code>struct Gamma&lt;&#x27;a&gt;(&amp;&#x27;a [usize]);</code> 仅当在 <code>&#x27;a</code> 为 <code>&#x27;static</code> 时有 <code>Gamma&lt;&#x27;a&gt;: &#x27;static</code>，否则不满足；</li><li><code>struct Delta&lt;T&gt;(T);</code> 仅当 <code>T: &#x27;static</code> 时有 <code>Delta&lt;T&gt;: &#x27;static</code>，否则不满足；</li></ul><p>如果一个值的类型不满足 <code>T: &#x27;static</code>，则这个值必须在类型上所标注的生命周期结束之前被释放掉。如果满足，则这个值可以存在任意长时间。显然一个值的生命周期不能超越约束其类型的生命周期，因此任何 <code>&amp;&#x27;static T</code> 引用中的 <code>T</code> 必然要满足 <code>T: &#x27;static</code>。</p><h3><code>static</code> 关键字</h3><p>以 <a href="https://doc.rust-lang.org/stable/std/keyword.static.html"><code>static</code> 关键字</a>声明的，形如 <code>static FOO: [i32; 5] = [1, 2, 3, 4, 5];</code> 的变量是<a title="static variable">静态变量</a>。</p><p>一个静态变量在程序的整个运行期间是唯一的，有唯一的地址，而且不会被释放。它可以被看作是 Rust 里的全局变量。显然如果一个静态变量的类型为 <code>T</code>，这个类型必须满足 <code>T: &#x27;static</code>，如此一来，这个类型的引用才是 <code>&amp;&#x27;static T</code>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/static-lifetime-bound-var.md">编辑</a>
  </article>
<article>
    <h2 id="trait-obj-upcast"><a href="#trait-obj-upcast">如果有一个 <code>trait Foo: Base</code>，如何将一个 <code>&amp;dyn Foo</code> 转换到 <code>&amp;dyn Base</code>？</a></h2><p>Rust 目前不直接提供这种转换，如果需要转换可以使用一个中间<a title="trait">特质</a>来实现，如</p><pre class="code"><span class="s-source s-rust"><span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Base</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...
</span></span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">AsBase</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span></span><span class="s-punctuation s-terminator s-rust">;</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-impl s-rust"><span class="s-storage s-type s-impl s-rust">impl</span></span><span class="s-meta s-impl s-rust"><span class="s-meta s-generic s-rust"><span class="s-punctuation s-definition s-generic s-begin s-rust">&lt;</span>T<span class="s-punctuation s-separator s-rust">:</span> Base<span class="s-punctuation s-definition s-generic s-end s-rust">&gt;</span></span></span><span class="s-meta s-impl s-rust"> AsBase <span class="s-keyword s-other s-rust">for</span></span><span class="s-meta s-impl s-rust"> <span class="s-entity s-name s-impl s-rust">T</span> </span><span class="s-meta s-impl s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span> </span><span class="s-meta s-function s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span> <span class="s-variable s-language s-rust">self</span> </span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Foo</span>: AsBase <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...
</span></span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span></pre><p>不支持的主要原因是在<a title="trait object">特质对象</a>的<a title="vtable">虚表</a>中没有相应的数据指向另一个特质的虚表，而不提供相应数据的原因可能是由于这很容易产生过多无用的虚表，进而导致二进制体积的膨胀。</p><p>更多关于这一话题的讨论可以参考 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 以及 <a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting">Traits, dynamic dispatch and upcasting</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/trait-obj-upcast.md">编辑</a>
  </article>
<article>
    <h2 id="vec-new-ptr"><a href="#vec-new-ptr">新创建的空 <code>Vec&lt;T&gt;</code> 的指针为何指向<code>1</code>、<code>2</code>、<code>4</code>、<code>8</code>等地址？</a></h2><p>当 <code>Vec</code> 的容量为0时，没有合法的操作会向其指针指向的位置进行读取和写入，进行任何读写之前都必然会有一次内存分配，因此这个初始的指针并不需要是一个有效的指针。这也使得创建 <code>Vec</code> 本身没有进行实际内存分配的必要，既省去了内存分配的开销，也让创建容器的操作可以在常量上下文中使用。</p><p>而因为 <code>Vec</code> 需要能被作为<a title="slice">切片</a>使用，由于切片对数据指针的<a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety">要求</a>，它的指针的地址需要是非空并且正确对齐的，因而简单起见便选择了类型的对齐的大小作为这个无效指针指向的地址。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/vec-new-ptr.md">编辑</a>
  </article>
<article>
    <h2 id="where-to-find-crates"><a href="#where-to-find-crates">有什么 crate 可以…？在哪找到它们？</a></h2><p>有很多 crates 列表，这里是其中的一些：</p><ul><li><a href="https://github.com/rust-unofficial/awesome-rust">rust-unofficial&#x2f;awesome-rust</a></li><li><a href="https://blessed.rs/crates">blessed.rs</a></li></ul>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/where-to-find-crates.md">编辑</a>
  </article>
<div class="add-container">
    <a class="add" href="https://github.com/rust-zh/faq/tree/master/content">+ 贡献新条目</a>
  </div>
</main>
<footer>
  <a class="telegram" href="https://t.me/rust_zh">Rust 众</a>
  <a rel="license" class="cc0" href="https://creativecommons.org/publicdomain/zero/1.0/deed.zh">CC0</a>
</footer>
</html>
